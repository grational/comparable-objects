package it.grational.aggregate

import spock.lang.*
import groovy.transform.*

/**
 * This Spock specification was auto generated by 'gigawatt'
 * @author d7392
 * @date 21-03-2021 06.07
 */
class AggregationListUSpec extends Specification {

	def "Should be capable of adding one element without any initialization"() {
		given: 'an instance of an AggregationList'
			def aggregator = new Object() as AggregationList<Integer>
		when:
			aggregator << 1
		then:
			aggregator.list == [1]
	}

	@Unroll
	def "Should be capable of append different elements to the internal list"() {
		given: 'an instance of an AggregationList'
			def aggregator = new Object() as AggregationList<Integer>
		and: 'initialize it'
			aggregator.list = initialList
		when:
			aggregator << newElement
		then:
			aggregator.list == expected
		where:
			initialList     | newElement || expected
			// numbers
			[1, 2, 3]       | 4          || [1, 2, 3, 4]
			[1, 2, 3]       | 2          || [1, 4, 3]
	}
	
	@Unroll
	def "Should be capable of appending different string elements to the internal list"() {
		given: 'an instance of an AggregationList'
			def aggregator = new Object() as AggregationList<String>
		and: 'initialize it'
			aggregator.list = initialList
		when:
			aggregator << newElement
		then:
			aggregator.list == expected
		where:
			initialList     | newElement || expected
			// letters
			['a', 'b', 'c'] | 'd'        || ['a', 'b', 'c', 'd']
			['a', 'b', 'c'] | 'b'        || ['a', 'bb', 'c']
	}

	def "Should refuse to add two different object"() {
		given:
			def a = new IdObject<Integer>(id: 'a')
		and:
			def b = new IdObject<Integer>(id: 'b')
		when:
			a + b
		then:
			def exception = thrown(IllegalArgumentException)
			exception.message == "[IdObject] Cannot add different objects!"
	}

	@Unroll
	def "Should be capable of summing with another AggregationList with integers"() {
		given:
			def left = new IdObject<Integer>(id: 'id')
		and:
			def right = new IdObject<Integer>(id: 'id')
		and: 'initialize it'
			left.list = leftList
			right.list = rightList
		when:
			def result = left + right
		then:
			result.list == expected
		where:
			leftList        | rightList   || expected
			// numbers
			[1, 2, 3]       | [4, 5, 6]   || [1, 2, 3, 4, 5, 6]
			[1, 2, 3]       | [1, 2]      || [2, 4, 3]
			[1, 2, 3]       | [1, 2, 1]   || [3, 4, 3]
	}

	@Unroll
	def "Should be capable of summing with another AggregationList with strings"() {
		given:
			def left = new IdObject<String>(id: 'id')
		and:
			def right = new IdObject<String>(id: 'id')
		and: 'initialize it'
			left.list = leftList
			right.list = rightList
		when:
			def result = left + right
		then:
			result.list == expected
		where:
			leftList        | rightList            || expected
			// letters
			['a', 'b', 'c'] | ['d', 'e', 'f']      || ['a', 'b', 'c', 'd', 'e', 'f']
			['a', 'b', 'c'] | ['a', 'b', 'c', 'd'] || ['aa', 'bb', 'cc', 'd']
			['a', 'b', 'c'] | ['a', 'b', 'a', 'd'] || ['aaa', 'bb', 'c', 'd']
	}

	def "Should work with custom Summable objects"() {
		given: 'two AggregationList instances with custom Summable objects'
			def left = new IdObject<TestValue>(id: 'id')
			def right = new IdObject<TestValue>(id: 'id')
		
		and: 'populated with test values'
			def val1 = new TestValue(name: 'one', value: 1)
			def val2 = new TestValue(name: 'two', value: 2)
			def val3 = new TestValue(name: 'three', value: 3)
			def val1Duplicate = new TestValue(name: 'one', value: 10)
			
			left.list = [val1, val2]
			right.list = [val1Duplicate, val3]
		
		when: 'adding them together'
			def result = left + right
			
		then: 'the values should be properly aggregated'
			result.list.size() == 3
			result.list[0].name == 'one'
			result.list[0].value == 11 // 1 + 10
			result.list[1].name == 'two'
			result.list[1].value == 2
			result.list[2].name == 'three'
			result.list[2].value == 3
	}
	
	@Unroll
	def "Should be capable of leftJoining with another AggregationList with integers"() {
		given:
			def left = new IdObject<Integer>(id: 'id')
		and:
			def right = new IdObject<Integer>(id: 'id')
		and: 'initialize it'
			left.list = leftList
			right.list = rightList
		when:
			def result = left.leftJoin(right)
		then:
			result.list == expected
		where:
			leftList        | rightList   || expected
			[1, 2, 3]       | [4, 5, 6]   || [1, 2, 3]
			[1, 2, 3]       | [1, 2]      || [2, 4, 3]
			[1, 2, 3]       | [1, 2, 1]   || [3, 4, 3]
			[1, 2]          | [2, 3, 4]   || [1, 4]
	}

	@Unroll
	def "Should be capable of leftJoining with another AggregationList with strings"() {
		given:
			def left = new IdObject<String>(id: 'id')
		and:
			def right = new IdObject<String>(id: 'id')
		and: 'initialize it'
			left.list = leftList
			right.list = rightList
		when:
			def result = left.leftJoin(right)
		then:
			result.list == expected
		where:
			leftList        | rightList            || expected
			['a', 'b']      | ['b', 'c', 'd']      || ['a', 'bb']
			['a', 'b', 'c'] | ['d', 'e', 'f']      || ['a', 'b', 'c']
			['a', 'b', 'c'] | ['a', 'b', 'c', 'd'] || ['aa', 'bb', 'cc']
	}
	
	def "Should work with custom Summable objects using leftJoin"() {
		given: 'two AggregationList instances with custom Summable objects'
			def left = new IdObject<TestValue>(id: 'id')
			def right = new IdObject<TestValue>(id: 'id')
		
		and: 'populated with test values'
			def val1 = new TestValue(name: 'one', value: 1)
			def val2 = new TestValue(name: 'two', value: 2)
			def val3 = new TestValue(name: 'three', value: 3)
			def val1Duplicate = new TestValue(name: 'one', value: 10)
			
			left.list = [val1, val2]
			right.list = [val1Duplicate, val3]
		
		when: 'left joining them'
			def result = left.leftJoin(right)
			
		then: 'only values from left list should be included with matching values merged'
			result.list.size() == 2
			result.list[0].name == 'one'
			result.list[0].value == 11 // 1 + 10
			result.list[1].name == 'two'
			result.list[1].value == 2
	}
	
	def "Should delegate list operations to the internal list"() {
		given: 'an AggregationList with elements'
			def aggregator = new IdObject<Integer>(id: 'id')
			aggregator.list = [1, 2, 3, 4, 5]
			
		expect: 'delegated methods to work correctly'
			aggregator.size() == 5
			!aggregator.isEmpty()
			aggregator.contains(3)
			!aggregator.contains(10)
			aggregator.sum() == 15
			aggregator.max() == 5
			aggregator.min() == 1
			aggregator.count { it % 2 == 0 } == 2 // count even numbers
			
		when: 'using iteration methods'
			def result = []
			aggregator.each { result << it * 2 }
			
		then: 'the iteration should work as expected'
			result == [2, 4, 6, 8, 10]
			
		when: 'using collect method'
			def mapped = aggregator.collect { it * 3 }
			
		then: 'the result should be as expected'
			mapped == [3, 6, 9, 12, 15]
	}
	
	def "Should correctly delegate findAll, any, and every methods"() {
		given: 'an AggregationList with mixed elements'
			def aggregator = new IdObject<Integer>(id: 'id')
			aggregator.list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
			
		expect: 'findAll should correctly filter elements'
			aggregator.findAll { it % 2 == 0 } == [2, 4, 6, 8, 10]
			aggregator.findAll { it > 7 } == [8, 9, 10]
			
		and: 'any should correctly check if any element matches the condition'
			aggregator.any { it > 9 }
			aggregator.any { it % 7 == 0 }
			!aggregator.any { it < 0 }
			
		and: 'every should correctly check if all elements match the condition'
			aggregator.every { it > 0 }
			aggregator.every { it <= 10 }
			!aggregator.every { it % 2 == 0 }
	}
	
	def "Should correctly delegate none method"() {
		given: 'an AggregationList with mixed elements'
			def aggregator = new IdObject<Integer>(id: 'id')
			aggregator.list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
			
		expect: 'none should correctly check if no element matches the condition'
			// Test that all elements don't satisfy the condition
			aggregator.none { it > 10 } == true
			aggregator.none { it == 0 } == true
			// Test that at least one element satisfies the condition
			aggregator.none { it % 2 == 0 } == false
	}

	@EqualsAndHashCode(includes='id')
	class IdObject<T> implements AggregationList<T> { 
		String id 
	}
	
	@ToString(includeFields = true, includePackage = false)
	@EqualsAndHashCode(includes = ['name'])
	class TestValue implements Summable<TestValue> {
		String name
		int value
		
		TestValue plus(TestValue other) {
			return new TestValue(name: this.name, value: this.value + other.value)
		}
	}
}
