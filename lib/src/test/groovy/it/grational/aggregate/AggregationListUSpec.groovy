package it.grational.aggregate

import spock.lang.*

/**
 * This Spock specification was auto generated by 'gigawatt'
 * @author d7392
 * @date 21-03-2021 06.07
 */
class AggregationListUSpec extends Specification {

	@Unroll
	def "Should be capable of append different elements to the internal list"() {
		given: 'instance an aggregator'
			def aggregator = new Object() as AggregationList
		and: 'initialize it'
			aggregator.list = initialList
		when:
			aggregator << newElement
		then:
			aggregator.list == expected
		where:
			initialList     | newElement || expected
			// numbers
			[1, 2, 3]       | 4          || [1, 2, 3, 4]
			[1, 2, 3]       | 2          || [1, 4, 3]
			// letters
			['a', 'b', 'c'] | 'd'        || ['a', 'b', 'c', 'd']
			['a', 'b', 'c'] | 'b'        || ['a', 'bb', 'c']
	}

	@Unroll
	def "Should be capable of summing itself with another AggregationList"() {
		given: 'instance an aggregator'
			def left = new Object() as AggregationList
		and:
			def right = new Object() as AggregationList
		and: 'initialize it'
			left.list = leftList
			right.list = rightList
		when:
			def result = left + right
		then:
			result == expected
		where:
			leftList        | rightList            || expected
			// numbers
			[1, 2, 3]       | [4, 5, 6]            || [1, 2, 3, 4, 5, 6]
			[1, 2, 3]       | [1, 2]               || [2, 4, 3]
			[1, 2, 3]       | [1, 2, 1]            || [3, 4, 3]
			// letters
			['a', 'b', 'c'] | ['d', 'e', 'f']      || ['a', 'b', 'c', 'd', 'e', 'f']
			['a', 'b', 'c'] | ['a', 'b', 'c', 'd'] || ['aa', 'bb', 'cc', 'd']
			['a', 'b', 'c'] | ['a', 'b', 'a', 'd'] || ['aaa', 'bb', 'c', 'd']
	}

}
